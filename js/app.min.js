(() => {
    "use strict";
    function t(t = () => {}) {
        let e = new Image();
        (e.onload = e.onerror = function () {
            t(2 == e.height);
        }),
            (e.src = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA");
    }
    t(function (t) {
        let e = !0 === t ? "webp" : "no-webp";
        document.documentElement.classList.add(e);
    });
    let e = document.getElementById("nav"),
        n = e.offsetTop;
    function i(t, e) {
        return e.indexOf(t) >= 0;
    }
    function s(t, e, n) {
        null != t.addEventListener ? t.addEventListener(e, n, !1) : null != t.attachEvent ? t.attachEvent(`on${e}`, n) : (t[e] = n);
    }
    function o(t, e, n) {
        null != t.removeEventListener ? t.removeEventListener(e, n, !1) : null != t.detachEvent ? t.detachEvent(`on${e}`, n) : delete t[e];
    }
    const l =
            window.WeakMap ||
            window.MozWeakMap ||
            class {
                constructor() {
                    (this.keys = []), (this.values = []);
                }
                get(t) {
                    for (let e = 0; e < this.keys.length; e++) if (this.keys[e] === t) return this.values[e];
                }
                set(t, e) {
                    for (let n = 0; n < this.keys.length; n++) if (this.keys[n] === t) return (this.values[n] = e), this;
                    return this.keys.push(t), this.values.push(e), this;
                }
            },
        a =
            window.MutationObserver ||
            window.WebkitMutationObserver ||
            window.MozMutationObserver ||
            class {
                constructor() {
                    "undefined" != typeof console &&
                        null !== console &&
                        (console.warn("MutationObserver is not supported by your browser."), console.warn("WOW.js cannot detect dom mutations, please call .sync() after loading new content."));
                }
                static notSupported = !0;
                observe() {}
            },
        r =
            window.getComputedStyle ||
            function (t) {
                const e = /(\-([a-z]){1})/g;
                return {
                    getPropertyValue(n) {
                        "float" === n && (n = "styleFloat"), e.test(n) && n.replace(e, (t, e) => e.toUpperCase());
                        const { currentStyle: i } = t;
                        return (null != i ? i[n] : void 0) || null;
                    },
                };
            };
    let c = new (class {
        defaults = { boxClass: "wow", animateClass: "animated", offset: 0, mobile: !0, live: !0, callback: null, scrollContainer: null, resetAnimation: !0 };
        constructor(t = {}) {
            (this.start = this.start.bind(this)),
                (this.resetAnimation = this.resetAnimation.bind(this)),
                (this.scrollHandler = this.scrollHandler.bind(this)),
                (this.scrollCallback = this.scrollCallback.bind(this)),
                (this.scrolled = !0),
                (this.config = (function (t, e) {
                    for (const n in e)
                        if (null == t[n]) {
                            const i = e[n];
                            t[n] = i;
                        }
                    return t;
                })(t, this.defaults)),
                null != t.scrollContainer && (this.config.scrollContainer = document.querySelector(t.scrollContainer)),
                (this.animationNameCache = new l()),
                (this.wowEvent = (function (t, e = !1, n = !1, i = null) {
                    let s;
                    return (
                        null != document.createEvent
                            ? ((s = document.createEvent("CustomEvent")), s.initCustomEvent(t, e, n, i))
                            : null != document.createEventObject
                            ? ((s = document.createEventObject()), (s.eventType = t))
                            : (s.eventName = t),
                        s
                    );
                })(this.config.boxClass));
        }
        init() {
            (this.element = window.document.documentElement), i(document.readyState, ["interactive", "complete"]) ? this.start() : s(document, "DOMContentLoaded", this.start), (this.finished = []);
        }
        start() {
            if (((this.stopped = !1), (this.boxes = [].slice.call(this.element.querySelectorAll(`.${this.config.boxClass}`))), (this.all = this.boxes.slice(0)), this.boxes.length))
                if (this.disabled()) this.resetStyle();
                else
                    for (let t = 0; t < this.boxes.length; t++) {
                        const e = this.boxes[t];
                        this.applyStyle(e, !0);
                    }
            this.disabled() || (s(this.config.scrollContainer || window, "scroll", this.scrollHandler), s(window, "resize", this.scrollHandler), (this.interval = setInterval(this.scrollCallback, 50))),
                this.config.live &&
                    new a((t) => {
                        for (let e = 0; e < t.length; e++) {
                            const n = t[e];
                            for (let t = 0; t < n.addedNodes.length; t++) {
                                const e = n.addedNodes[t];
                                this.doSync(e);
                            }
                        }
                    }).observe(document.body, { childList: !0, subtree: !0 });
        }
        stop() {
            (this.stopped = !0), o(this.config.scrollContainer || window, "scroll", this.scrollHandler), o(window, "resize", this.scrollHandler), null != this.interval && clearInterval(this.interval);
        }
        sync() {
            a.notSupported && this.doSync(this.element);
        }
        doSync(t) {
            if ((null == t && ({ element: t } = this), 1 !== t.nodeType)) return;
            const e = (t = t.parentNode || t).querySelectorAll(`.${this.config.boxClass}`);
            for (let t = 0; t < e.length; t++) {
                const n = e[t];
                i(n, this.all) || (this.boxes.push(n), this.all.push(n), this.stopped || this.disabled() ? this.resetStyle() : this.applyStyle(n, !0), (this.scrolled = !0));
            }
        }
        show(t) {
            var e, n;
            return (
                this.applyStyle(t),
                (t.className = `${t.className} ${this.config.animateClass}`),
                null != this.config.callback && this.config.callback(t),
                (e = t),
                (n = this.wowEvent),
                null != e.dispatchEvent ? e.dispatchEvent(n) : n in (null != e) ? e[n]() : `on${n}` in (null != e) && e[`on${n}`](),
                this.config.resetAnimation && (s(t, "animationend", this.resetAnimation), s(t, "oanimationend", this.resetAnimation), s(t, "webkitAnimationEnd", this.resetAnimation), s(t, "MSAnimationEnd", this.resetAnimation)),
                t
            );
        }
        applyStyle(t, e) {
            const n = t.getAttribute("data-wow-duration"),
                i = t.getAttribute("data-wow-delay"),
                s = t.getAttribute("data-wow-iteration");
            return this.animate(() => this.customStyle(t, e, n, i, s));
        }
        animate = (function () {
            return "requestAnimationFrame" in window ? (t) => window.requestAnimationFrame(t) : (t) => t();
        })();
        resetStyle() {
            for (let t = 0; t < this.boxes.length; t++) this.boxes[t].style.visibility = "visible";
        }
        resetAnimation(t) {
            if (t.type.toLowerCase().indexOf("animationend") >= 0) {
                const e = t.target || t.srcElement;
                e.className = e.className.replace(this.config.animateClass, "").trim();
            }
        }
        customStyle(t, e, n, i, s) {
            return (
                e && this.cacheAnimationName(t),
                (t.style.visibility = e ? "hidden" : "visible"),
                n && this.vendorSet(t.style, { animationDuration: n }),
                i && this.vendorSet(t.style, { animationDelay: i }),
                s && this.vendorSet(t.style, { animationIterationCount: s }),
                this.vendorSet(t.style, { animationName: e ? "none" : this.cachedAnimationName(t) }),
                t
            );
        }
        vendors = ["moz", "webkit"];
        vendorSet(t, e) {
            for (const n in e)
                if (e.hasOwnProperty(n)) {
                    const i = e[n];
                    t[`${n}`] = i;
                    for (let e = 0; e < this.vendors.length; e++) t[`${this.vendors[e]}${n.charAt(0).toUpperCase()}${n.substr(1)}`] = i;
                }
        }
        vendorCSS(t, e) {
            const n = r(t);
            let i = n.getPropertyCSSValue(e);
            for (let t = 0; t < this.vendors.length; t++) {
                const s = this.vendors[t];
                i = i || n.getPropertyCSSValue(`-${s}-${e}`);
            }
            return i;
        }
        animationName(t) {
            let e;
            try {
                e = this.vendorCSS(t, "animation-name").cssText;
            } catch (n) {
                e = r(t).getPropertyValue("animation-name");
            }
            return "none" === e ? "" : e;
        }
        cacheAnimationName(t) {
            return this.animationNameCache.set(t, this.animationName(t));
        }
        cachedAnimationName(t) {
            return this.animationNameCache.get(t);
        }
        scrollHandler() {
            this.scrolled = !0;
        }
        scrollCallback() {
            if (this.scrolled) {
                this.scrolled = !1;
                const t = [];
                for (let e = 0; e < this.boxes.length; e++) {
                    const n = this.boxes[e];
                    if (n) {
                        if (this.isVisible(n)) {
                            this.show(n);
                            continue;
                        }
                        t.push(n);
                    }
                }
                (this.boxes = t), this.boxes.length || this.config.live || this.stop();
            }
        }
        offsetTop(t) {
            for (; void 0 === t.offsetTop; ) t = t.parentNode;
            let e = t.offsetTop;
            for (; t.offsetParent; ) e += (t = t.offsetParent).offsetTop;
            return e;
        }
        isVisible(t) {
            const e = t.getAttribute("data-wow-offset") || this.config.offset,
                n = (this.config.scrollContainer && this.config.scrollContainer.scrollTop) || window.pageYOffset,
                i = n + Math.min(this.element.clientHeight, "innerHeight" in window ? window.innerHeight : document.documentElement.clientHeight) - e,
                s = this.offsetTop(t),
                o = s + t.clientHeight;
            return s <= i && o >= n;
        }
        disabled() {
            return !this.config.mobile && ((t = navigator.userAgent), /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(t));
            var t;
        }
    })();
    t(),
        (window.onscroll = function () {
            window.pageYOffset > n ? e.classList.add("sticky") : e.classList.remove("sticky");
        }),
        (function () {
            let t = document.getElementById("hamMenu"),
                e = document.getElementById("nav");
            t.addEventListener("click", function () {
                return t.classList.length > 1 ? t.classList.remove("is-open") : t.classList.add("is-open");
            }),
                t.addEventListener("click", function () {
                    let t = document.getElementById("myLinks");
                    "block" === t.style.display ? ((t.style.display = "none"), (e.style.background = "")) : ((t.style.display = "block"), (e.style.background = "#fff"));
                });
        })(),
        (function () {
            let t = new Date().getFullYear();
            document.getElementById("infY").textContent = t - 2019;
        })(),
        (function () {
            let t = document.querySelector(".recent-works");
            document.getElementById("infP").textContent = t.children.length;
        })(),
        (function () {
            let t = document.getElementById("infS"),
                e = 0;
            setInterval(function () {
                (e += 1), (t.textContent = e);
            }, 1e3);
        })(),
        (document.getElementById("thisDate").textContent = new Date().getFullYear()),
        c.init();
})();
